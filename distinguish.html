<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2025-06-22 Sun 12:43 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Explosives and Distinguishers</title>
<meta name="author" content="Nathan" />
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" type="text/css" href="myStyle.css" />
</head>
<body>
<div id="org-div-home-and-up"><a href="index.html">‚Ü©</a></div><div id="content" class="content">
<h1 class="title">Explosives and Distinguishers</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org1643494">Distinguishers</a></li>
<li><a href="#orgeaa644c">Equality Explosion</a></li>
</ul>
</div>
</div>
<p>
<i><b>Abstract.</b> TODO</i> Testing
</p>

<p>
This piece is contains quite a few (read: far too many) proofs in <a href="https://docs.racket-lang.org/pie/index.html">Pie</a>,
a simple, beautiful, but verbose dependently typed programming
language.<sup><a id="fnr.1" class="footref" href="#fn.1" role="doc-backlink">1</a></sup> Before getting started, a small logical interface
used throughout to make proofs more readable:
</p>

<div class="org-src-container">
<pre class="src src-lisp">#lang pie

(claim &#8869; U)
(define &#8869; Absurd)

(claim &#8868; U)
(define &#8868; Trivial)

(claim &#172; (&#8594; U U))
(define &#172; (&#955; (A) (&#8594; A &#8869;)))

(claim &#8743; (&#8594; U U U))
(define &#8743; (&#955; (A B) (Pair A B)))

(claim &#8744; (&#8594; U U U))
(define &#8744; (&#955; (A B) (Either A B)))

(claim &#8596; (&#8594; U U U))
(define &#8596; (&#955; (A B) (&#8743; (&#8594; A B) (&#8594; B A))))
</pre>
</div>

<p>
I recently spent an inordinate amount of time thinking about Pie
formalizations of the following theorem:
</p>

<blockquote>
<p>
<i>1 = 0 implies I am the Pope.</i>
</p>
</blockquote>

<p>
I was interested primarily in proofs that could be carried out in the
minimal fragment of Pie, i.e., without the use of <a href="https://docs.racket-lang.org/pie/index.html#%28def._%28%28lib._pie%2Fmain..rkt%29._ind-.Absurd%29%29"><code>ind-Absurd</code></a>, the
induction principle for the empty type which expresses the <a href="https://en.wikipedia.org/wiki/Principle_of_explosion">principle
of explosion</a>.
</p>

<p>
Working in this vein leads one naturally to a standard fact of
constructive mathematics: 1 = 0 is <i>explosive</i> in the sense that
anything follows from it in the minimal fragment of Pie.<sup><a id="fnr.2" class="footref" href="#fn.2" role="doc-backlink">2</a></sup>
</p>

<div class="org-src-container">
<pre class="src src-lisp">(claim explode-1=0
  (&#8594; (= Nat 1 0) (&#928; ((A U)) A)))
(define explode-1=0
  (&#955; (1=0 A)
     (replace
       1=0
       (&#955; (a) (which-Nat a A (&#955; (_) &#8868;)))
       sole)))
</pre>
</div>

<p>
And leads one further to a natural enough question: <i>which equalities
are explosive?</i>
</p>
<div id="outline-container-org1643494" class="outline-2">
<h2 id="org1643494">Distinguishers</h2>
<div class="outline-text-2" id="text-org1643494">
<p>
Its straightforward enought to generalize the above proof to any fixed
pair of natural numbers.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(claim sub1 (&#8594; Nat Nat))
(define sub1
  (&#955; (n)
     (which-Nat n 0 (&#955; (n-1) n-1))))

(claim &#8760; (&#8594; Nat Nat Nat))
(define &#8760;
  (&#955; (m n)
     (iter-Nat n m sub1)))

(claim 5=7&#8594;1=0
  (&#8594; (= Nat 5 7) (= Nat 1 0)))
(define 5=7&#8594;1=0
  (&#955; (5=7)
     (symm
       (cong
         5=7
         (<span style="color: #a020f0;">the</span>
           (&#8594; Nat Nat)
           (&#955; (n) (&#8760; n 6)))))))

(claim explode-5=7
  (&#8594; (= Nat 5 7) (&#928; ((A U)) A)))
(define explode-5=7
  (&#955; (5=7)
     (explode-1=0 (5=7&#8594;1=0 5=7))))
</pre>
</div>

<p>
It also works for the equality true = false, given the standard sum
type encoding of Booleans.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(claim Bool U)
(define Bool (Either &#8868; &#8868;))

(claim true Bool)
(define true (left sole))

(claim false Bool)
(define false (right sole))

(claim ind-Bool
  (&#928; ((target Bool)
      (motive (&#8594; Bool U))
      (true-case (motive true))
      (false-case (motive false)))
     (motive target)))
(define ind-Bool
  (&#955; (target motive true-case false-case)
     (ind-Either
       target
       motive
       (&#955; (_) true-case)
       (&#955; (_) false-case))))

(claim bool&#8594;nat (&#8594; Bool Nat))
(define bool&#8594;nat
  (&#955; (b) (ind-Bool b (&#955; (_) Nat) 1 0)))

(claim true=false&#8594;1=0
  (&#8594; (= Bool true false) (= Nat 1 0)))
(define true=false&#8594;1=0
  (&#955; (true=false) (cong true=false bool&#8594;nat)))

(claim explode-true=false
  (&#8594; (= Bool true false) (&#928; ((A U)) A)))
(define explode-true=false
  (&#955; (true=false)
     (explode-1=0 (true=false&#8594;1=0 true=false))))
</pre>
</div>

<p>
All we're doing here is bootstrapping; if an equality implies 1 = 0
then it's explosive.  This is not so natural a condition, but it hints
at a natural enough definition which captures what's going on: A
boolean function ùëì : ùê¥ ‚Üí Bool <i>distinguishes</i> two values ùëé and ùëè if ùëì
ùëé is true and ùëì ùëè is false.  Furthermore, ùëé and ùëè are
<i>distinguishable</i>, written ùëé ‚óá ùëè, if they have a distinguisher.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(claim Distinguishes
  (&#928; ((A U)
      (f (&#8594; A Bool)))
     (&#8594; A A U)))
(define Distinguishes
  (&#955; (_ f x y)
     (&#8743; (= Bool (f x) true)
        (= Bool (f y) false))))

(claim &#9671;
  (&#928; ((A U))
     (&#8594; A A U)))
(define &#9671;
  (&#955; (A x y)
     (&#931; ((f (&#8594; A Bool)))
        (Distinguishes A f x y))))

<span style="color: #b22222;">; </span><span style="color: #b22222;">the following are getters for &#9671;</span>

(claim distinguisher-&#9671;
  (&#928; ((A U)
      (x A)
      (y A)
      (x&#9671;y (&#9671; A x y)))
     (&#8594; A Bool)))
(define distinguisher-&#9671;
  (&#955; (_ _ _ x&#9671;y)
     (car x&#9671;y)))

(claim distinguishes-fst
  (&#928; ((A U)
      (x A)
      (y A)
      (x&#9671;y (&#9671; A x y)))
     (= Bool
        (distinguisher-&#9671; A x y x&#9671;y x)
        true)))
(define distinguishes-fst
  (&#955; (_ _ _ x&#9671;y)
     (car (cdr x&#9671;y))))

(claim distinguishes-snd
  (&#928; ((A U)
      (x A)
      (y A)
      (x&#9671;y (&#9671; A x y)))
     (= Bool
        (distinguisher-&#9671; A x y x&#9671;y y)
        false)))
(define distinguishes-snd
  (&#955; (_ _ _ x&#9671;y)
     (cdr (cdr x&#9671;y))))
</pre>
</div>

<p>
Distinguishability gives us a way of capturing more generally what's
going on in the case of 5 = 7 and true = false.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(claim &#9671;&#8594;explode&#8316;
  (&#928; ((A U)
      (x A)
      (y A))
     (&#8594; (&#9671; A x y)
        (= A x y)
        (&#928; ((B U)) B))))
(define &#9671;&#8594;explode&#8316;
  (&#955; (A x y x&#9671;y x=y)
    (explode-true=false
      (trans
        <span style="color: #b22222;">; true = f x</span>
        (symm (distinguishes-fst A x y x&#9671;y))
        (trans
          <span style="color: #b22222;">; f x = f y</span>
          (cong x=y (distinguisher-&#9671; A x y x&#9671;y))
          <span style="color: #b22222;">; f y = false</span>
          (distinguishes-snd A x y x&#9671;y))))))
</pre>
</div>

<p>
In other words, <i>any equality of distinguishable terms is explosive.</i>
</p>
</div>
</div>
<div id="outline-container-orgeaa644c" class="outline-2">
<h2 id="orgeaa644c">Equality Explosion</h2>
<div class="outline-text-2" id="text-orgeaa644c">
<p>
Distinguishability is a strictly stronger relation than inquality in
the minimal fragment of Pie.<sup><a id="fnr.3" class="footref" href="#fn.3" role="doc-backlink">3</a></sup>
</p>

<div class="org-src-container">
<pre class="src src-lisp">(claim &#9671;&#8594;&#8800;
  (&#928; ((A U)
      (x A)
      (y A))
     (&#8594; (&#9671; A x y)
        (&#8800; A x y))))
(define &#9671;&#8594;&#8800;
  (&#955; (A x y x&#9671;y x=y)
     (&#9671;&#8594;explode&#8316; A x y x&#9671;y x=y &#8869;)))

(claim &#10216;&#8800;&#8594;&#9671;&#10217;&#8594;ind-&#8869;
  (&#8594; (&#928; ((A U)
         (x A)
         (y A))
        (&#8594; (&#8800; A x y)
           (&#9671; A x y)))
     (&#8594; &#8869; &#928; ((A U)) A))))
(define &#10216;&#8800;&#8594;&#9671;&#10217;&#8594;ind-&#8869;
  (&#955; (&#8800;&#8594;&#9671; absurd)
     (&#9671;&#8594;explode&#8316;
       &#8868;
       sole
       sole
       (&#8800;&#8594;&#9671;
         &#8868;
         sole
         sole
         (&#955; (_) absurd))
       (same sole))))
</pre>
</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1" role="doc-backlink">1</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">TODO</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2" role="doc-backlink">2</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">See
Proposition 3.2 of Constructivism in Mathematics by Trolestra and van
Dalen.</p></div></div>

<div class="footdef"><sup><a id="fn.3" class="footnum" href="#fnr.3" role="doc-backlink">3</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Moving forward, we'll take
advantage of the fact that the principle of explosion is not a theorem
of the minimal fragment of Pie. In particular, in order to show that a
claim is not a theorem, it suffices to demonstrate that it implies
explosion.</p></div></div>


</div>
</div></div>
</body>
</html>
