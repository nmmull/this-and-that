#+TITLE: Explosives and Distinguishers
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="myStyle.css" />
#+OPTIONS: html-style:nil H:1 num:nil
#+HTML_LINK_HOME: index.html

/*Abstract.* TODO/ Testing

This piece is contains quite a few (read: far too many) proofs in [[https://docs.racket-lang.org/pie/index.html][Pie]],
a simple, beautiful, but verbose dependently typed programming
language.[fn::TODO] Before getting started, a small logical interface
used throughout to make proofs more readable:

#+begin_src lisp
  #lang pie

  (claim ⊥ U)
  (define ⊥ Absurd)

  (claim ⊤ U)
  (define ⊤ Trivial)

  (claim ¬ (→ U U))
  (define ¬ (λ (A) (→ A ⊥)))

  (claim ∧ (→ U U U))
  (define ∧ (λ (A B) (Pair A B)))

  (claim ∨ (→ U U U))
  (define ∨ (λ (A B) (Either A B)))

  (claim ↔ (→ U U U))
  (define ↔ (λ (A B) (∧ (→ A B) (→ B A))))
#+end_src

I recently spent an inordinate amount of time thinking about Pie
formalizations of the following theorem:

#+begin_quote
/1 = 0 implies I am the Pope./
#+end_quote

I was interested primarily in proofs that could be carried out in the
minimal fragment of Pie, i.e., without the use of [[https://docs.racket-lang.org/pie/index.html#%28def._%28%28lib._pie%2Fmain..rkt%29._ind-.Absurd%29%29][~ind-Absurd~]], the
induction principle for the empty type which expresses the [[https://en.wikipedia.org/wiki/Principle_of_explosion][principle
of explosion]].

Working in this vein leads one naturally to a standard fact of
constructive mathematics: 1 = 0 is /explosive/ in the sense that
anything follows from it in the minimal fragment of Pie.[fn::See
Proposition 3.2 of Constructivism in Mathematics by Trolestra and van
Dalen.]

#+begin_src lisp
  (claim explode-1=0
    (→ (= Nat 1 0) (Π ((A U)) A)))
  (define explode-1=0
    (λ (1=0 A)
       (replace
         1=0
         (λ (a) (which-Nat a A (λ (_) ⊤)))
         sole)))
#+end_src

And leads one further to a natural enough question: /which equalities
are explosive?/

* Distinguishers

Its straightforward enought to generalize the above proof to any fixed
pair of natural numbers.

#+begin_src lisp
  (claim sub1 (→ Nat Nat))
  (define sub1
    (λ (n)
       (which-Nat n 0 (λ (n-1) n-1))))

  (claim ∸ (→ Nat Nat Nat))
  (define ∸
    (λ (m n)
       (iter-Nat n m sub1)))

  (claim 5=7→1=0
    (→ (= Nat 5 7) (= Nat 1 0)))
  (define 5=7→1=0
    (λ (5=7)
       (symm
         (cong
           5=7
  	 (the
  	   (→ Nat Nat)
  	   (λ (n) (∸ n 6)))))))

  (claim explode-5=7
    (→ (= Nat 5 7) (Π ((A U)) A)))
  (define explode-5=7
    (λ (5=7)
       (explode-1=0 (5=7→1=0 5=7))))
#+end_src

It also works for the equality true = false, given the standard sum
type encoding of Booleans.

#+begin_src lisp
  (claim Bool U)
  (define Bool (Either ⊤ ⊤))

  (claim true Bool)
  (define true (left sole))

  (claim false Bool)
  (define false (right sole))

  (claim ind-Bool
    (Π ((target Bool)
        (motive (→ Bool U))
        (true-case (motive true))
        (false-case (motive false)))
       (motive target)))
  (define ind-Bool
    (λ (target motive true-case false-case)
       (ind-Either
         target
         motive
         (λ (_) true-case)
         (λ (_) false-case))))

  (claim bool→nat (→ Bool Nat))
  (define bool→nat
    (λ (b) (ind-Bool b (λ (_) Nat) 1 0)))

  (claim true=false→1=0
    (→ (= Bool true false) (= Nat 1 0)))
  (define true=false→1=0
    (λ (true=false) (cong true=false bool→nat)))

  (claim explode-true=false
    (→ (= Bool true false) (Π ((A U)) A)))
  (define explode-true=false
    (λ (true=false)
       (explode-1=0 (true=false→1=0 true=false))))
#+end_src

All we're doing here is bootstrapping; if an equality implies 1 = 0
then it's explosive.  This is not so natural a condition, but it hints
at a natural enough definition which captures what's going on: A
boolean function 𝑓 : 𝐴 → Bool /distinguishes/ two values 𝑎 and 𝑏 if 𝑓
𝑎 is true and 𝑓 𝑏 is false.  Furthermore, 𝑎 and 𝑏 are
/distinguishable/, written 𝑎 ◇ 𝑏, if they have a distinguisher.

#+begin_src lisp
  (claim Distinguishes
    (Π ((A U)
        (f (→ A Bool)))
       (→ A A U)))
  (define Distinguishes
    (λ (_ f x y)
       (∧ (= Bool (f x) true)
          (= Bool (f y) false))))

  (claim ◇
    (Π ((A U))
       (→ A A U)))
  (define ◇
    (λ (A x y)
       (Σ ((f (→ A Bool)))
          (Distinguishes A f x y))))

  ; the following are getters for ◇

  (claim distinguisher-◇
    (Π ((A U)
        (x A)
        (y A)
        (x◇y (◇ A x y)))
       (→ A Bool)))
  (define distinguisher-◇
    (λ (_ _ _ x◇y)
       (car x◇y)))

  (claim distinguishes-fst
    (Π ((A U)
        (x A)
        (y A)
        (x◇y (◇ A x y)))
       (= Bool
          (distinguisher-◇ A x y x◇y x)
          true)))
  (define distinguishes-fst
    (λ (_ _ _ x◇y)
       (car (cdr x◇y))))

  (claim distinguishes-snd
    (Π ((A U)
        (x A)
        (y A)
        (x◇y (◇ A x y)))
       (= Bool
          (distinguisher-◇ A x y x◇y y)
          false)))
  (define distinguishes-snd
    (λ (_ _ _ x◇y)
       (cdr (cdr x◇y))))
#+end_src

Distinguishability gives us a way of capturing more generally what's
going on in the case of 5 = 7 and true = false.

#+begin_src lisp
  (claim ◇→explode⁼
    (Π ((A U)
        (x A)
        (y A))
       (→ (◇ A x y)
          (= A x y)
          (Π ((B U)) B))))
  (define ◇→explode⁼
    (λ (A x y x◇y x=y)
      (explode-true=false
        (trans
          ; true = f x
          (symm (distinguishes-fst A x y x◇y))
          (trans
            ; f x = f y
            (cong x=y (distinguisher-◇ A x y x◇y))
            ; f y = false
            (distinguishes-snd A x y x◇y))))))
#+end_src

In other words, /any equality of distinguishable terms is explosive./

* Equality Explosion

Distinguishability is a strictly stronger relation than inquality in
the minimal fragment of Pie.[fn::Moving forward, we'll take
advantage of the fact that the principle of explosion is not a theorem
of the minimal fragment of Pie. In particular, in order to show that a
claim is not a theorem, it suffices to demonstrate that it implies
explosion.]

#+begin_src lisp
  (claim ◇→≠
    (Π ((A U)
        (x A)
        (y A))
       (→ (◇ A x y)
          (≠ A x y))))
  (define ◇→≠
    (λ (A x y x◇y x=y)
       (◇→explode⁼ A x y x◇y x=y ⊥)))

  (claim ⟨≠→◇⟩→ind-⊥
    (→ (Π ((A U)
           (x A)
           (y A))
          (→ (≠ A x y)
             (◇ A x y)))
       (→ ⊥ Π ((A U)) A))))
  (define ⟨≠→◇⟩→ind-⊥
    (λ (≠→◇ absurd)
       (◇→explode⁼
         ⊤
         sole
         sole
         (≠→◇
           ⊤
  	 sole
  	 sole
  	 (λ (_) absurd))
         (same sole))))
#+end_src
