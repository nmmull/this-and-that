#+TITLE: Explosives and Distinguishers
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="myStyle.css" />
#+OPTIONS: html-style:nil H:1 num:nil
#+HTML_LINK_HOME: index.html

/*Abstract.* TODO/ Testing

This piece is contains quite a few (read: far too many) proofs in [[https://docs.racket-lang.org/pie/index.html][Pie]],
a simple, beautiful, but verbose dependently typed programming
language.[fn::TODO] Before getting started, a small logical interface
used throughout to make proofs more readable:

#+begin_src lisp
  #lang pie

  (claim âŠ¥ U)
  (define âŠ¥ Absurd)

  (claim âŠ¤ U)
  (define âŠ¤ Trivial)

  (claim Â¬ (â†’ U U))
  (define Â¬ (Î» (A) (â†’ A âŠ¥)))

  (claim âˆ§ (â†’ U U U))
  (define âˆ§ (Î» (A B) (Pair A B)))

  (claim âˆ¨ (â†’ U U U))
  (define âˆ¨ (Î» (A B) (Either A B)))

  (claim â†” (â†’ U U U))
  (define â†” (Î» (A B) (âˆ§ (â†’ A B) (â†’ B A))))
#+end_src

I recently spent an inordinate amount of time thinking about Pie
formalizations of the following theorem:

#+begin_quote
/1 = 0 implies I am the Pope./
#+end_quote

I was interested primarily in proofs that could be carried out in the
minimal fragment of Pie, i.e., without the use of [[https://docs.racket-lang.org/pie/index.html#%28def._%28%28lib._pie%2Fmain..rkt%29._ind-.Absurd%29%29][~ind-Absurd~]], the
induction principle for the empty type which expresses the [[https://en.wikipedia.org/wiki/Principle_of_explosion][principle
of explosion]].

Working in this vein leads one naturally to a standard fact of
constructive mathematics: 1 = 0 is /explosive/ in the sense that
anything follows from it in the minimal fragment of Pie.[fn::See
Proposition 3.2 of Constructivism in Mathematics by Trolestra and van
Dalen.]

#+begin_src lisp
  (claim explode-1=0
    (â†’ (= Nat 1 0) (Î  ((A U)) A)))
  (define explode-1=0
    (Î» (1=0 A)
       (replace
         1=0
         (Î» (a) (which-Nat a A (Î» (_) âŠ¤)))
         sole)))
#+end_src

And leads one further to a natural enough question: /which equalities
are explosive?/

* Distinguishers

Its straightforward enought to generalize the above proof to any fixed
pair of natural numbers.

#+begin_src lisp
  (claim sub1 (â†’ Nat Nat))
  (define sub1
    (Î» (n)
       (which-Nat n 0 (Î» (n-1) n-1))))

  (claim âˆ¸ (â†’ Nat Nat Nat))
  (define âˆ¸
    (Î» (m n)
       (iter-Nat n m sub1)))

  (claim 5=7â†’1=0
    (â†’ (= Nat 5 7) (= Nat 1 0)))
  (define 5=7â†’1=0
    (Î» (5=7)
       (symm
         (cong
           5=7
  	 (the
  	   (â†’ Nat Nat)
  	   (Î» (n) (âˆ¸ n 6)))))))

  (claim explode-5=7
    (â†’ (= Nat 5 7) (Î  ((A U)) A)))
  (define explode-5=7
    (Î» (5=7)
       (explode-1=0 (5=7â†’1=0 5=7))))
#+end_src

It also works for the equality true = false, given the standard sum
type encoding of Booleans.

#+begin_src lisp
  (claim Bool U)
  (define Bool (Either âŠ¤ âŠ¤))

  (claim true Bool)
  (define true (left sole))

  (claim false Bool)
  (define false (right sole))

  (claim ind-Bool
    (Î  ((target Bool)
        (motive (â†’ Bool U))
        (true-case (motive true))
        (false-case (motive false)))
       (motive target)))
  (define ind-Bool
    (Î» (target motive true-case false-case)
       (ind-Either
         target
         motive
         (Î» (_) true-case)
         (Î» (_) false-case))))

  (claim boolâ†’nat (â†’ Bool Nat))
  (define boolâ†’nat
    (Î» (b) (ind-Bool b (Î» (_) Nat) 1 0)))

  (claim true=falseâ†’1=0
    (â†’ (= Bool true false) (= Nat 1 0)))
  (define true=falseâ†’1=0
    (Î» (true=false) (cong true=false boolâ†’nat)))

  (claim explode-true=false
    (â†’ (= Bool true false) (Î  ((A U)) A)))
  (define explode-true=false
    (Î» (true=false)
       (explode-1=0 (true=falseâ†’1=0 true=false))))
#+end_src

All we're doing here is bootstrapping; if an equality implies 1 = 0
then it's explosive.  This is not so natural a condition, but it hints
at a natural enough definition which captures what's going on: A
boolean function ğ‘“ : ğ´ â†’ Bool /distinguishes/ two values ğ‘ and ğ‘ if ğ‘“
ğ‘ is true and ğ‘“ ğ‘ is false.  Furthermore, ğ‘ and ğ‘ are
/distinguishable/, written ğ‘ â—‡ ğ‘, if they have a distinguisher.

#+begin_src lisp
  (claim Distinguishes
    (Î  ((A U)
        (f (â†’ A Bool)))
       (â†’ A A U)))
  (define Distinguishes
    (Î» (_ f x y)
       (âˆ§ (= Bool (f x) true)
          (= Bool (f y) false))))

  (claim â—‡
    (Î  ((A U))
       (â†’ A A U)))
  (define â—‡
    (Î» (A x y)
       (Î£ ((f (â†’ A Bool)))
          (Distinguishes A f x y))))

  ; the following are getters for â—‡

  (claim distinguisher-â—‡
    (Î  ((A U)
        (x A)
        (y A)
        (xâ—‡y (â—‡ A x y)))
       (â†’ A Bool)))
  (define distinguisher-â—‡
    (Î» (_ _ _ xâ—‡y)
       (car xâ—‡y)))

  (claim distinguishes-fst
    (Î  ((A U)
        (x A)
        (y A)
        (xâ—‡y (â—‡ A x y)))
       (= Bool
          (distinguisher-â—‡ A x y xâ—‡y x)
          true)))
  (define distinguishes-fst
    (Î» (_ _ _ xâ—‡y)
       (car (cdr xâ—‡y))))

  (claim distinguishes-snd
    (Î  ((A U)
        (x A)
        (y A)
        (xâ—‡y (â—‡ A x y)))
       (= Bool
          (distinguisher-â—‡ A x y xâ—‡y y)
          false)))
  (define distinguishes-snd
    (Î» (_ _ _ xâ—‡y)
       (cdr (cdr xâ—‡y))))
#+end_src

Distinguishability gives us a way of capturing more generally what's
going on in the case of 5 = 7 and true = false.

#+begin_src lisp
  (claim â—‡â†’explodeâ¼
    (Î  ((A U)
        (x A)
        (y A))
       (â†’ (â—‡ A x y)
          (= A x y)
          (Î  ((B U)) B))))
  (define â—‡â†’explodeâ¼
    (Î» (A x y xâ—‡y x=y)
      (explode-true=false
        (trans
          ; true = f x
          (symm (distinguishes-fst A x y xâ—‡y))
          (trans
            ; f x = f y
            (cong x=y (distinguisher-â—‡ A x y xâ—‡y))
            ; f y = false
            (distinguishes-snd A x y xâ—‡y))))))
#+end_src

In other words, /any equality of distinguishable terms is explosive./

* Equality Explosion

Distinguishability is a strictly stronger relation than inquality in
the minimal fragment of Pie.[fn::Moving forward, we'll take
advantage of the fact that the principle of explosion is not a theorem
of the minimal fragment of Pie. In particular, in order to show that a
claim is not a theorem, it suffices to demonstrate that it implies
explosion.]

#+begin_src lisp
  (claim â—‡â†’â‰ 
    (Î  ((A U)
        (x A)
        (y A))
       (â†’ (â—‡ A x y)
          (â‰  A x y))))
  (define â—‡â†’â‰ 
    (Î» (A x y xâ—‡y x=y)
       (â—‡â†’explodeâ¼ A x y xâ—‡y x=y âŠ¥)))

  (claim âŸ¨â‰ â†’â—‡âŸ©â†’ind-âŠ¥
    (â†’ (Î  ((A U)
           (x A)
           (y A))
          (â†’ (â‰  A x y)
             (â—‡ A x y)))
       (â†’ âŠ¥ Î  ((A U)) A))))
  (define âŸ¨â‰ â†’â—‡âŸ©â†’ind-âŠ¥
    (Î» (â‰ â†’â—‡ absurd)
       (â—‡â†’explodeâ¼
         âŠ¤
         sole
         sole
         (â‰ â†’â—‡
           âŠ¤
  	 sole
  	 sole
  	 (Î» (_) absurd))
         (same sole))))
#+end_src
