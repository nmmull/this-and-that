#+title: Doing Reverse Mathematics
#+author: Nathan Mull
#+date: 2025-07-28
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="myStyle.css" />
#+OPTIONS: html-style:nil H:1 num:nil
#+HTML_LINK_HOME: index.html
These are a typed-up version of the notes taken during the second and
third session of /An Informal Seminar on Reverse Mathematics/.

*The usual disclaimer:* they're pretty rough, but I want to make sure
those who attended have access.
* Introduction
The goal of this part of the seminar is to "do" some reverse
mathematics. This isn't so different from doing "normal" mathematics,
except that you have one hand tied behind your back, so to speak:
+ We can't just "do" induction or comprehension whenever we want.
  Subsystems of second order arithmetic have restricted induction and
  comprehension principles, and we need to make sure we respect these
  restrictions.
+ We can't construct any mathematical structures we want.  We have to
  make sure all the structures we want to work with are /encodable/
  within second-order arithmetic.
Doing reverse mathematics is also about meta-theory:
+ reversals, i.e., proving axioms from theorems;
+ separations, i.e., showing that an axiom doesn't follow from the
  others.
This is a lot, and not really all that reasonable to cover in two
hour-long sessions, but to get a /taste/ of all of these components,
I'd like to look at a particular reversal:[fn::This is a nice reversal
to look at after having studied GÃ¶del's incompleteness theorems, given
that the machinery for "doing" logic in second-order arithmetic is
essentially the same as that needed to define GÃ¶del sentences in
first-order arithmetic.]
#+begin_quote
  /Weak KÃ¶nig's Lemma (WKL) is equivalent to Lindenbaum's Lemma (LL)
  with respect to computable mathematics (RCAâ‚€)./
#+end_quote
We'll begin with an informal presentation of this reversal (i.e., in
"normal" mathematics) and then look at what needs to be done to make
this a formal theorem of the meta-theory of RCAâ‚€, the subsystem of
second-order arithmetic that captures doing mathematics in the world
where all sets are computable.
* WKL â†” LL (Informally)
Weak KÃ¶nig's Lemma (WKL) is a fairly intuitive set-theoretic result
about infinite binary trees.

*Lemma.* (WLK) Every infinite binary tree has an infinite path.

/Proof sketch./ (in "normal" mathematics) Suppose we're given an
infinite binary tree ğ‘‡.  Because ğ‘‡ is infinite, it must have a left
subtree ğ‘‡â‚€ or a right subtree ğ‘‡â‚. If it has both, then one of these
two subtrees is infinite.  Without loss of generality, let's say the
left subtree ğ‘‡â‚€ is infinite. By induction, ğ‘‡â‚€ has an infinite path ğ‘ƒ
(since ğ‘‡â‚€ is an infinite binary tree). Therefore, therefore 0ğ‘ƒ (i.e.,
the path ğ‘ƒ with 0 concatenated to the front) is an infinite path in
ğ‘‡. âˆ

A key feature of this proof: /in order to extend the path we're
building, we need to reason about whether or not a binary tree is
infinite/. That is, if we're given choice between ğ’¯â‚€ and ğ’¯â‚, we have
to be able to choose one that's infinite.  We'll come back to
this. First, in order to aid what follows, we'll make WKL a bit more
formal.

*Definition.* Let ğ‘â‚, ğ‘â‚‚ âˆˆ {0, 1}* be finite binary strings. We say ğ‘â‚
is an *initial segment* of ğ‘â‚‚, written ğ‘â‚ â‰º ğ‘â‚‚, if there is a binary
string ğ‘ such that ğ‘â‚ğ‘ = ğ‘â‚‚.  For example, 01100 is an initial segment
of 011000110.

*Definition.* A *tree* is a set ğ‘‡ âŠ‚ {0, 1}* which is closed under
initial segments, i.e., if ğ‘ âˆˆ ğ‘‡ and ğ‘ â‰º ğ‘ then ğ‘ âˆˆ ğ‘‡.

*Definition.* A *path* is a function ğ‘ƒ : â„• â†’ {0, 1} such that

#+begin_quote
ğ‘ƒ(0) ğ‘ƒ(1) ... ğ‘ƒ(ğ‘˜ - 1) âˆˆ ğ‘‡
#+end_quote
for every ğ‘˜ âˆˆ â„•.


/Proof sketch./ (WKL, slightly more formal) let ğ‘‡ be an infinite
binary tree.  Define ğ‘‡â‚€ = { ğ‘ : 0ğ‘ âˆˆ ğ‘‡ } and ğ‘‡â‚ = { ğ‘ : 1ğ‘ âˆˆ ğ‘‡ }. Note
that both ğ‘‡â‚€ and ğ‘‡â‚ are binary trees. And since ğ‘‡ is infinite, ğ‘‡â‚€ or
ğ‘‡â‚ is infinite.  Suppose without loss of generality that ğ‘‡â‚€ is
infinite.  By induction, there is a path ğ‘ƒâ€² in ğ‘‡â‚€. Define ğ‘ƒ(0) = 0
and, for ğ‘– âˆˆ â„•âº, ğ‘ƒ(ğ‘– + 1) = ğ‘ƒâ€²(ğ‘–). Then ğ‘ƒ is a path in ğ‘‡. âˆ

Next up, Lindenbaum's lemma (LL).

*Definition.* A *completion* of a theory ğ’¯ is a theory ğ’¯* âŠƒ ğ’¯ which is
consistent:

#+begin_quote
âˆ„Ï• . ğ’¯ âŠ¢ Ï• and ğ’¯ âŠ¢ Â¬Ï•
#+end_quote

complete:

#+begin_quote
âˆ€ Ï• . ğ’¯ âŠ¢ Ï• or ğ’¯ âŠ¢ Â¬Ï•
#+end_quote

and closed under logical consequence.

*Lemma.* (LL) Every consistent theory has a completion.

/Proof sketch./ We might already see that this lemma has a
similar flavor to WKL, so let's use WKL to prove it.

Let ğ’¯ be a consistent theory and let Ï•â‚€, Ï•â‚,... be an enumeration of
the sentences in our language.

Our approach is to build a binary tree in which each branch is a
decision as to whether we should add a given sentence Ï• or its
negation Â¬Ï• to ğ’¯.  An infinite path then represents a choice for all
sentences, giving us a completion.

Now let's fix some notation: we'll write Ï•[0] for Â¬Ï• and Ï•[1]
for Ï•. For a binary string ğ‘ âˆˆ {0, 1}áµ, we can consider the theory

ğ’¯[ğ‘] = ğ’¯ + Ï•â‚€[ğ‘(1)] + Ï•â‚[ğ‘(1)] + ... + Ï•â‚–[ğ‘(ğ‘˜)]

Define the set ğ‘‡ = { ğ‘ : ğ’¯[ğ‘] is consistent }. This is an infinite
binary tree (you may need to think about this for a second), so by WKL
it has a path ğ‘ƒ. The set { Ï•áµ¢[ğ‘ƒ(i)] : i âˆˆ â„• } is a completion of ğ’¯. âˆ

There's a fair amount of mathematical symbology in the above proof,
but it basically says: /WKL gives us a way of choosing which sentences
to add to our completion./ And in the same way that proving WKL
requires us to determine which of two trees is infinite, proving LL
requires us to determine which of two theories is consistent.

Now, for the main event of this section, the reversal.

*Theorem.* LL implies WLK.

/Proof sketch./ Proving a reversal often comes down to a trick, or a
"gadget." In this case, we need to define a theory whose completion
defines a path through a given tree ğ‘‡.

We work over a theory with nullary relations (i.e., constants) of the
form ğ¿â‚€, ğ¿â‚, ...  We think of ğ¿áµ¢ as "go left at the ğ‘–th level." That
way, if we get a completion ğ’¯* of a theory ğ’¯, we can read off a path ğ‘ƒ
as

#+begin_quote
ğ‘ƒ(i) = ğŸ™[ğ¿áµ¢ âˆˆ ğ’¯*]
#+end_quote

That is, a completion is forced to choose a path (because it can't
prove both ğ¿áµ¢ and Â¬ğ¿áµ¢, but it must prove one of them).

It then comes down making sure that these choices "keep us in the
tree." The trick: our theory describes where /not/ to go to find an
infinite path.

Let ğ‘ âˆˆ {0, 1}áµ be a binary string /not/ in ğ‘‡ and define the sentence:

#+begin_quote
Ïˆ[ğ‘] = Â¬(ğ¿â‚€[ğ‘(0)] âˆ§ ğ¿â‚[ğ‘(1)] âˆ§ ... âˆ§ ğ¿â‚–[ğ‘(ğ‘˜)])
#+end_quote

This sentences encodes the statement "don't go down a path which
starts with ğ‘."  We then define the theory

#+begin_quote
ğ’¯ = { Ïˆ[ğ‘] : ğ‘ âˆ‰ ğ‘‡ }
#+end_quote


This is a consistent theory (you may need to think about this for a
second) so by LL it has a completion ğ’¯*. We can define the function

#+begin_quote
ğ‘ƒ(ğ‘–) = ğŸ™[ğ¿áµ¢ âˆˆ ğ’¯*]
#+end_quote

Consider the binary string ğ‘ƒ(0) ... ğ‘ƒ(ğ‘˜). By definition of ğ‘ƒ,

#+begin_quote
ğ’¯* âŠ¢ ğ¿â‚€[P(0)] âˆ§ ... âˆ§ ğ¿â‚–[P(ğ‘˜)]
#+end_quote

If ğ‘ƒ(0) ... ğ‘ƒ(ğ‘˜) âˆ‰ ğ‘‡ then, by definition of ğ’¯,

#+begin_quote
ğ’¯* âŠ¢ Â¬(ğ¿â‚€[P(0)] âˆ§ ... âˆ§ ğ¿â‚–[P(ğ‘˜)])
#+end_quote

contradicting consistency. Therefore, implies ğ‘ƒ(0) ... ğ‘ƒ(ğ‘˜) âˆˆ ğ‘‡. Since
ğ‘˜ was arbitrary, it follows that ğ‘ƒ is a path in ğ‘‡. âˆ

Part of the point here is that ğ‘‡ may have many paths, but we don't
necessarily have a way of finding them.  The theory we defined
says where /not/ to go, but doesn't give us a way of choosing
an actual path. Applying LL /forces/ a choice.

All this tells us that WKL and LL are, in some sense, logically
equivalent. Denis Hirschfeldt says that WKL is the "combinatorial
core" of LL; it acts like roadmap for what's "actually going on" in
the proof.  And what amazingâ”€what reverse mathematics tells usâ”€is
that this roadmap is shared by /many/ theorems, about compactness in
the topological sense, about completeness in the logical sense, about
properties of continuous functions, etc., etc.

But there's one aspect of what we've done so far that's /very/
unsatisfying from a mathematical perspective: /WKL and LL are already
theorems of "normal" mathematics./ Sure, we used WKL in a nontrivial
way in the proof of LL, and vice versa, but formally defining "in a
nontrivial way" is difficult.  Ideally, we could worked in a setting
where WKL and LL are /not/ theorems but their equivalence still holds.
In other words, if ğ’® âŠ¬ WLK and ğ’® âŠ¬ LL but ğ’® âŠ¢ WLK â†” LL, then we're
/guaranteed/ to have used WKL and LL nontrivially in proving the
equivalence.

The system that's traditionally used which has this property is RCAâ‚€,
a subsystem of second-order arithmetic whose universe of sets is
computable in a formal sense.  In order to define this subsystem, we
need to introduce the machinery of second-order arithmetic.

* Subsystems of Second-Order Arithmetic

In this section, we're gonna do something kinda boring, we're gonna
give a specification of a logical language, like we do in intro logic
courses.  I hope that this can be skimmed by those familiar with the
concepts, and can be used as a more complete (albeit somewhat
pedantic) presentation of second-order arithmetic than is typically
given in (graduate) texts on reverse mathematics.

Subsystems of second order arithmetic are defined over the language â„’â‚‚, which has

| binary functions | +, *                |
| binary relation  | <                   |
| constants        | 0, 1                |

and is defined over a set of number variables ğ• (written as lowercase
letters) and a set of set variables ğ•Š (written as uppercase letters).


The set of terms ğ•‹ is defined inductively:

| 0 âˆˆ ğ•‹                            | (zero)            |
| 1 âˆˆ ğ•‹                            | (one)             |
| x âˆˆ ğ• implies x âˆˆ ğ•‹              | (number variables) |
| tâ‚, tâ‚‚ âˆˆ ğ•‹ implies (tâ‚ + tâ‚‚) âˆˆ ğ•‹ | (addition)        |
| tâ‚, tâ‚‚ âˆˆ ğ•‹ implies (tâ‚ * tâ‚‚) âˆˆ ğ•‹ | (multiplication)  |

For example, (((x + 1) * 0) âˆˆ ğ•‹).[fn::We'll use the usual rules to
eliminate parentheses and write "((x + 1) * 0) âˆˆ T" instead.]  The set of
atomic formulas ğ”¸ is defined inductively:

| tâ‚, tâ‚‚ âˆˆ ğ•‹ implies (tâ‚ = tâ‚‚) âˆˆ ğ”¸     | (equality)   |
| tâ‚, tâ‚‚ âˆˆ ğ•‹ implies (tâ‚ < tâ‚‚) âˆˆ ğ”¸     | (less-than)  |
| t âˆˆ ğ•‹ and X âˆˆ ğ•Š implies (t âˆˆ X) âˆˆ ğ”¸ | (element-of) |

For example, (1 + y) âˆˆ X and (a * 0) = a are in ğ”¸. The set of
formulas ğ”½ is defined inductively:

| Ï• âˆˆ ğ”¸ implies Ï• âˆˆ ğ”½                 | (atomic)                    |
| Ï•â‚, Ï•â‚‚ âˆˆ ğ”½ implies (Ï•â‚ âˆ§ Ï•â‚‚) âˆˆ ğ”½   | (conjunction)               |
| Ï•â‚, Ï•â‚‚ âˆˆ ğ”½ implies (Ï•â‚ âˆ¨ Ï•â‚‚) âˆˆ ğ”½   | (disjunction)               |
| Ï• âˆˆ ğ”½ implies (Â¬Ï•) âˆˆ ğ”½              | (negation)                  |
| x âˆˆ ğ• and Ï• âˆˆ ğ”½ implies (âˆ€x.Ï•) âˆˆ ğ”½ | (universal number quant.)   |
| x âˆˆ ğ• and Ï• âˆˆ ğ”½ implies (âˆƒx.Ï•) âˆˆ ğ”½ | (existential number quant.) |
| X âˆˆ ğ•Š and Ï• âˆˆ ğ”½ implies (âˆ€X.Ï•) âˆˆ ğ”½ | (universal set quant.)      |
| X âˆˆ ğ•Š and Ï• âˆˆ ğ”½ implies (âˆƒX.Ï•) âˆˆ ğ”½ | (existential set quant.)    |

For example, âˆƒX.âˆ€n(n âˆˆ X â†’ âˆƒk.(k + k = n)) is a formula in ğ”½ (assuming the
translation Ï• â†’ Ïˆ â‰¡ Â¬Ï• âˆ¨ Ïˆ) which expresses that there is a set that
contains only even numbers (though not necessarily all even numbers).

Every subsystem of second-order arithmetic we'll look at has the same
base set of axioms â„¬:

| âˆ€n. 1 + n â‰  0                                   | (succ. is not zero)   |
| âˆ€m.âˆ€n.(1 + m = 1 + n â†’ m = n)                   | (succ. is injective)  |
| âˆ€m.0 + m = m                                    | (def. addition)       |
| âˆ€m.âˆ€n.((1 + m) + n = 1 + (m + n))               | (def. addition)       |
| âˆ€m.0 Ã— m = 0                                    | (def. multiplication) |
| âˆ€m.âˆ€n.((1 + m) Ã— n = n + (m * n))               | (def. multiplication) |
| âˆ€m.Â¬(m < 0)                                     | (zero is minimum)     |
| âˆ€m.âˆ€n.(m < n + 1 â†” (m < n âˆ¨ m = n))             | (discreteness)        |
| âˆ€X.(0 âˆˆ X âˆ§ âˆ€n.(n âˆˆ X â†’ 1 + n âˆˆ X) â†’ âˆ€n(n âˆˆ X) | (2nd-Ord Induction)   |

The subsystems we'll consider differ in their induction and
comprehension principles.  The restriction on these axiom schemas
comes from how "complex" of formulas we're allowed to use.

*Definition.* The â„±-comprehension schema is the axiom schema
consisting formulas of the form

#+begin_quote
âˆƒX.âˆ€n(n âˆˆ X â†” Ï•(n))
#+end_quote

where Ï• âˆˆ â„±.

*Definition.* The â„±-induction schema is the axiom schema
consisting of formulas of the form

#+begin_quote
Ï•(0) âˆ§ âˆ€n.(Ï•(n) â†’ Ï•(1 + n)) â†’ âˆ€n.Ï•(n)
#+end_quote

where Ï• âˆˆ â„±.

The question then is: /what does it mean for a formula to be more or
less complex?/ Borrowing intuitions from computability theory, it
comes down to /quantifier alternation/. The reason for this is
deep[fn::If you're interested look up Post's Theorem.] but for our
purposes it's sufficient to recognize checking satisfiability of
âˆƒ-statements and unsatisfiability of âˆ€-statements amounts to a /search
problem/.  This, in essence, means that the satisfiability problem
becomes harder as you alternate quantifiers, which gives us a good
measure of formula complexity.

One caveat: if we're using difficulty of the satisfiability problem as
a measure of complexity, then quantifier-free is not the "least
complex" class of formulas. This is because we easily solve the satisfiability
problem for formulas with /bounded quantifiers/, i.e., when we know
exactly how much searching we need to do.  We'll use the following
notation for /bounded quantifiers/:

#+begin_quote
âˆ€(n < k).Ï• â‰¡ âˆ€n.(n < k â†’ Ï•)
#+end_quote

#+begin_quote
âˆƒ(n < k).Ï• â‰¡ âˆƒn.(n < k âˆ§ Ï•)
#+end_quote

We define Î£â°â‚€ = Î â°â‚€ inductively:

| Ï• âˆˆ ğ”½ and Ï• is quantifier-free implies Ï• âˆˆ Î£â°â‚€        |
| Ï• âˆˆ Î£â°â‚€ and x âˆˆ ğ• and k âˆˆ ğ•‹ implies âˆ€(x < k).Ï• âˆˆ Î£â°â‚€ |
| Ï• âˆˆ Î£â°â‚€ and x âˆˆ ğ• and k âˆˆ ğ•‹ implies âˆƒ(x < k).Ï• âˆˆ Î£â°â‚€ |

In other words, we close under bounded-quantifiers. This class of
formulas has the property that the satisfaction problem is computable
(and with a fairly predictable running time).  For example
#+begin_quote
âˆƒk < (1 + n).(k * m = n)
#+end_quote
is a formula in Î£â°â‚€ which expresses that m divides n. Note that we
don't have to search above n for the value of k such that k * m = n,
since n â‰¤ n * m when m > 0.

We define the sets Î£â°áµ¢â‚Šâ‚ and Î â°áµ¢â‚Šâ‚ inductively:

| Ï• âˆˆ Î â°áµ¢ and x âˆˆ ğ•  implies âˆƒx.Ï• âˆˆ Î£â°áµ¢â‚Šâ‚ |
| Ï• âˆˆ Î£â°áµ¢ and x âˆˆ ğ•  implies âˆ€x.Ï• âˆˆ Î â°áµ¢â‚Šâ‚ |

For example, a formula in Î â°â‚… is of the form âˆ€x.âˆƒy.âˆ€z.âˆƒw.âˆ€q.Ï• where Ï•
has only bounded quantifiers.

All of this is in the interests of (this corollary of) Post's
Theorem.[fn::Here I'm assuming some degree of familiarity with basic
concepts of computability theory. I wanted to avoid making this
assumption, but I don't think this is possible.]

*Theorem.* A set ğ‘‹ is computably enumerable if and only if it is
definable by a Î£â°â‚ formula and is computable if it is also definable
by a Î â°â‚ formula.

This theorem connects definability with computability. Sets which are
definable by both a Î£â°áµ¢ and a Î â°áµ¢ formula are called Î”â°áµ¢. These set
classifications are part of what is called the /arithmetic hierarchy/,
another term worth searching if you're interested in the connections
between computability and definability.

* RCAâ‚€: Computable Mathematics

The last thing we need to define RCAâ‚€ is a special form of
comprehension.

*Definition.* The Î”â°áµ¢-comprehension schema is the axiom schema
consisting formulas of the form

#+begin_quote
âˆ€n.(Ï•(n) â†” Ïˆ(n)) â†’ âˆƒX.âˆ€n(n âˆˆ X â†” Ï•(n))
#+end_quote

where Ï• âˆˆ Î£â°áµ¢ and Ïˆ âˆˆ Î â°áµ¢.

You may be thinking: /why can't we define Î”â°áµ¢-comprehension as a
â„±-comprehension schema like above?/ This is because Î”â°áµ¢ is not a set
of formulas, where as Î£â°áµ¢ and Î â°áµ¢ are.


Finally, we have enough machinery to define RCAâ‚€:

#+begin_quote
RCAâ‚€ â‰¡ â„¬ + Î£â°â‚-induction + Î”â°â‚-comprehension
#+end_quote

In light of the discussion above, this means RCAâ‚€ is the subsystem of
second-order arithmetic in which we can do comprehension for
/computable sets/ and induction for singly-existential statements.

*(This is where we got in session 2)*
